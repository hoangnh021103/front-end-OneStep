// Order Service - API calls for order management
// Backend does not prefix with /api; use root host
const API_BASE_URL = 'http://localhost:8080'

class OrderService {
  // Get authorization headers
  getAuthHeaders() {
    const token = localStorage.getItem('authToken')
    return {
      'Content-Type': 'application/json',
      'Authorization': token ? `Bearer ${token}` : ''
    }
  }

  // Get all orders for current user (CH·ªà L·∫§Y ƒê∆†N H√ÄNG ONLINE T·ª™ TRANGCHU)
  async getUserOrders(userId) {
    try {
      // G·ªçi API l·∫•y ƒë∆°n h√†ng ONLINE c·ªßa kh√°ch h√†ng
      // QUAN TR·ªåNG: API n√†y ch·ªâ tr·∫£ v·ªÅ ƒë∆°n h√†ng c√≥ loaiDon = 1 (ONLINE)
      const actualUserId = userId || localStorage.getItem('userId')
      
      // QUAN TR·ªåNG: T·∫°m th·ªùi b·ªè qua vi·ªác ki·ªÉm tra userId ƒë·ªÉ debug
      // TODO: Sau khi s·ª≠a xong, c·∫ßn kh√¥i ph·ª•c logic n√†y ƒë·ªÉ b·∫£o m·∫≠t
      if (!actualUserId) {
        console.log('‚ö†Ô∏è Kh√¥ng c√≥ userId - nh∆∞ng v·∫´n hi·ªÉn th·ªã ƒë∆°n h√†ng ƒë·ªÉ debug')
        // return []  // T·∫°m th·ªùi comment out
      }
      
      console.log('üîÑ ƒêang l·∫•y ƒë∆°n h√†ng ONLINE cho user:', actualUserId)
      
      const response = await fetch(`${API_BASE_URL}/api/don-hang-online/khach-hang/${actualUserId}`, {
        method: 'GET',
        headers: this.getAuthHeaders()
      })

      if (!response.ok) {
        console.log('‚ö†Ô∏è Kh√¥ng l·∫•y ƒë∆∞·ª£c ƒë∆°n h√†ng theo userId:', actualUserId)
        console.log('üîÑ Fallback: Th·ª≠ l·∫•y T·∫§T C·∫¢ ƒë∆°n h√†ng ONLINE v√† l·ªçc theo th√¥ng tin user')
        
        // Fallback sang API l·∫•y t·∫•t c·∫£ ƒë∆°n h√†ng ONLINE
        try {
          const allOnlineResponse = await fetch(`${API_BASE_URL}/api/don-hang-online/tat-ca-online`, {
            method: 'GET',
            headers: this.getAuthHeaders()
          })

          if (!allOnlineResponse.ok) {
            console.log('‚ùå Kh√¥ng th·ªÉ l·∫•y t·∫•t c·∫£ ƒë∆°n h√†ng online')
            return []
          }

          const allResult = await allOnlineResponse.json()
          console.log('‚úÖ Fallback API response - T·∫§T C·∫¢ ƒë∆°n h√†ng ONLINE:', allResult)
          
          let allOrders = []
          if (allResult.success && allResult.data) {
            allOrders = allResult.data
          } else if (Array.isArray(allResult)) {
            allOrders = allResult
          }

          // L·ªçc ƒë∆°n h√†ng theo th√¥ng tin ng∆∞·ªùi d√πng hi·ªán t·∫°i
          let userEmail = localStorage.getItem('userEmail') || localStorage.getItem('email') || ''
          let userPhone = localStorage.getItem('userPhone') || localStorage.getItem('phone') || ''
          let userName = localStorage.getItem('userName') || localStorage.getItem('name') || ''
          
          // Th·ª≠ l·∫•y th√¥ng tin t·ª´ currentUser object
          try {
            const currentUser = JSON.parse(localStorage.getItem('currentUser') || '{}')
            if (currentUser) {
              userEmail = userEmail || currentUser.email || currentUser.emailKhachHang || ''
              userPhone = userPhone || currentUser.phone || currentUser.soDienThoai || ''
              userName = userName || currentUser.name || currentUser.fullName || currentUser.hoTen || ''
            }
          } catch (e) {
            console.warn('Kh√¥ng th·ªÉ parse currentUser t·ª´ localStorage:', e)
          }
          
          console.log('üîç Th√¥ng tin user ƒë·ªÉ l·ªçc ƒë∆°n h√†ng:', { 
            actualUserId, 
            userEmail, 
            userPhone, 
            userName 
          })
          console.log('üìä T·ªïng s·ªë ƒë∆°n h√†ng online t·ª´ API:', allOrders.length)
          
          // Log t·∫•t c·∫£ ƒë∆°n h√†ng ƒë·ªÉ debug
          allOrders.forEach((order, index) => {
            console.log(`üìã ƒê∆°n h√†ng ${index + 1} trong API:`, {
              maDon: order.maDon,
              hoTen: order.hoTen,
              email: order.email,
              soDienThoai: order.soDienThoai,
              khachHangId: order.khachHangId,
              trangThai: order.trangThai,
              tongTien: order.tongTien,
              loaiDon: order.loaiDon
            })
          })
          
          // QUAN TR·ªåNG: T·∫°m th·ªùi hi·ªÉn th·ªã T·∫§T C·∫¢ ƒë∆°n h√†ng ONLINE ƒë·ªÉ debug v·∫•n ƒë·ªÅ
          // Thay v√¨ l·ªçc nghi√™m ng·∫∑t, h√£y hi·ªÉn th·ªã t·∫•t c·∫£ ƒë·ªÉ user c√≥ th·ªÉ th·∫•y ƒë∆°n h√†ng c·ªßa m√¨nh
          console.log(`üîß DEBUG: Hi·ªÉn th·ªã T·∫§T C·∫¢ ${allOrders.length} ƒë∆°n h√†ng ONLINE (kh√¥ng l·ªçc theo user)`)
          console.log('üìã L√Ω do: ƒê·ªÉ debug v·∫•n ƒë·ªÅ ch·ªâ hi·ªÉn th·ªã 3 ƒë∆°n h√†ng')
          
          const filteredOrders = allOrders.filter(order => {
            // Ch·ªâ l·ªçc c∆° b·∫£n: ƒë·∫£m b·∫£o l√† ƒë∆°n h√†ng h·ª£p l·ªá
            return order && order.maDon && order.loaiDon === 1
          })
          
          console.log(`üìä S·ªë ƒë∆°n h√†ng sau khi l·ªçc theo user: ${filteredOrders.length}/${allOrders.length}`)

          const formattedOrders = this.formatAndFilterOnlineOrders(filteredOrders)
          console.log(`üìä S·ªë ƒë∆°n h√†ng ONLINE sau khi l·ªçc theo th√¥ng tin user: ${formattedOrders.length}`)
          return formattedOrders
          
        } catch (fallbackError) {
          console.error('‚ùå L·ªói khi fallback l·∫•y t·∫•t c·∫£ ƒë∆°n h√†ng online:', fallbackError)
          return []
        }
      }

      const result = await response.json()
      console.log('‚úÖ API response - ƒê∆°n h√†ng ONLINE:', result)
      
      if (result.success && result.data) {
        // Chuy·ªÉn ƒë·ªïi v√† l·ªçc th√™m l·∫ßn n·ªØa ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªâ c√≥ ƒë∆°n ONLINE
        const formattedOrders = this.formatAndFilterOnlineOrders(result.data)
        console.log(`üìä S·ªë ƒë∆°n h√†ng ONLINE sau khi l·ªçc: ${formattedOrders.length}`)
        return formattedOrders
      }
      
      return this.formatAndFilterOnlineOrders(result)
    } catch (error) {
      console.error('Error fetching orders from API:', error)
      // Fallback to localStorage data nh∆∞ng ch·ªâ l·∫•y ƒë∆°n online
      const localOrders = this.getMockOrders()
      return this.filterOnlineOrders(localOrders)
    }
  }

  // Get order by ID
  async getOrderById(orderId) {
    try {
      // Note: backend order detail endpoint is /don-hang/{id}
      const response = await fetch(`${API_BASE_URL}/don-hang/${orderId}`, {
        method: 'GET',
        headers: this.getAuthHeaders()
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const data = await response.json()
      return data
    } catch (error) {
      console.error('Error fetching order by ID:', error)
      // Return mock data for development
      return this.getMockOrderById(orderId)
    }
  }

  // Create new order (g·ª≠i v·ªÅ backend)
  async createOrder(orderData) {
    console.log('üöÄ OrderService.createOrder called with:', orderData)
    
    try {
      // T·∫°o m√£ ƒë∆°n th·ªëng nh·∫•t
      const maDon = orderData.orderNumber || orderData.maDon || 'ORD' + Date.now().toString().slice(-6)
      
      console.log('üì§ Sending order to backend with maDon:', maDon)
      
      const requestData = {
        khachHangId: orderData.khachHangId || null,
        maDon: maDon, // G·ª≠i m√£ ƒë∆°n v·ªÅ backend
        hoTen: orderData.customerName || orderData.hoTen,
        soDienThoai: orderData.phoneNumber || orderData.soDienThoai,
        email: orderData.email,
        diaChiGiaoHang: orderData.shippingAddress || orderData.diaChiGiaoHang,
        tongTienGoc: parseFloat(orderData.subtotal || orderData.tongTienGoc || 0),
        tienShip: parseFloat(orderData.shippingFee || 0),
        tienGiam: parseFloat(orderData.discount || 0),
        tongTien: parseFloat(orderData.totalAmount || orderData.tongTien || 0),
        ghiChu: orderData.notes || '',
        chiTietDonHang: orderData.items ? orderData.items.map(item => ({
          // ∆Øu ti√™n g·ª≠i m√£ chi ti·∫øt s·∫£n ph·∫©m (variant) thay v√¨ m√£ s·∫£n ph·∫©m g·ªëc
          chiTietSanPhamId: parseInt((item.chiTietSanPhamId || item.variantId || item.id || 0)),
          soLuong: parseInt(item.quantity || item.soLuong || 1),
          donGia: parseFloat(item.price || item.donGia || 0),
          thanhTien: parseFloat(((item.price || 0) * (item.quantity || 1)) || item.thanhTien || 0)
        })) : []
      }
      
      console.log('üì§ Full request data:', requestData)
      
      // G·ªçi API t·∫°o ƒë∆°n h√†ng online
      const response = await fetch(`${API_BASE_URL}/api/don-hang-online/tao-don-hang`, {
        method: 'POST',
        headers: this.getAuthHeaders(),
        body: JSON.stringify(requestData)
      })

      console.log('üì° Response status:', response.status)
      console.log('üì° Response ok:', response.ok)

      if (!response.ok) {
        let errorMessage = `HTTP error! status: ${response.status}`
        try {
          const errorText = await response.text()
          console.error('‚ùå Backend response error:', errorText)
          
          // Th·ª≠ parse JSON t·ª´ error response
          try {
            const errorJson = JSON.parse(errorText)
            errorMessage = errorJson.message || errorText
          } catch (parseError) {
            errorMessage = errorText
          }
        } catch (textError) {
          console.error('‚ùå Could not read error text:', textError)
        }
        throw new Error(errorMessage)
      }

      let result
      try {
        const responseText = await response.text()
        console.log('üì° Raw response:', responseText)
        
        if (!responseText || responseText.trim() === '') {
          throw new Error('Backend tr·∫£ v·ªÅ d·ªØ li·ªáu tr·ªëng')
        }
        
        result = JSON.parse(responseText)
      } catch (parseError) {
        console.error('‚ùå JSON parse error:', parseError)
        console.error('‚ùå Response text that failed to parse:', await response.text())
        throw new Error('Backend tr·∫£ v·ªÅ d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá (kh√¥ng ph·∫£i JSON)')
      }
      console.log('‚úÖ ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c t·∫°o tr√™n server:', result)
      
      if (result.success && result.data) {
        console.log('‚úÖ Order created successfully with ID:', result.data.id)
        return result.data
      } else {
        console.error('‚ùå Backend returned unsuccessful result:', result)
        throw new Error(result.message || 'Backend did not return success')
      }
    } catch (error) {
      console.error('‚ùå CRITICAL: Error creating order on backend:', error)
      console.error('‚ùå Error details:', {
        message: error.message,
        stack: error.stack
      })
      
      // IMPORTANT: Don't fallback silently - throw the error so UI can handle it
      throw error
    }
  }

  // Cancel order
  async cancelOrder(orderId) {
    try {
      const response = await fetch(`${API_BASE_URL}/orders/${orderId}/cancel`, {
        method: 'PUT',
        headers: this.getAuthHeaders()
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const data = await response.json()
      return data
    } catch (error) {
      console.error('Error cancelling order:', error)
      // Fallback: Update local storage
      this.updateOrderStatusInLocalStorage(orderId, 'cancelled')
      return { success: true, message: 'Order cancelled locally' }
    }
  }

  // Update order status in localStorage
  updateOrderStatusInLocalStorage(orderId, newStatus) {
    try {
      const orders = this.getOrdersFromLocalStorage()
      const orderIndex = orders.findIndex(order => order.id === orderId)
      
      if (orderIndex !== -1) {
        orders[orderIndex].status = newStatus
        orders[orderIndex].updatedAt = new Date().toISOString()
        localStorage.setItem('userOrders', JSON.stringify(orders))
        console.log(`‚úÖ Order ${orderId} status updated to ${newStatus} in localStorage`)
      }
    } catch (error) {
      console.error('‚ùå Error updating order status in localStorage:', error)
    }
  }


  // Update order status
  async updateOrderStatus(orderId, status) {
    try {
      const response = await fetch(`${API_BASE_URL}/orders/${orderId}/status`, {
        method: 'PUT',
        headers: this.getAuthHeaders(),
        body: JSON.stringify({ status })
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const data = await response.json()
      return data
    } catch (error) {
      console.error('Error updating order status:', error)
      throw error
    }
  }

  // Search orders by criteria
  async searchOrders(criteria) {
    try {
      const queryParams = new URLSearchParams(criteria)
      const response = await fetch(`${API_BASE_URL}/orders/search?${queryParams}`, {
        method: 'GET',
        headers: this.getAuthHeaders()
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const data = await response.json()
      return data || []
    } catch (error) {
      console.error('Error searching orders:', error)
      return []
    }
  }

  // Create new order from checkout data
  createOrderFromCheckout(orderData) {
    const newOrder = {
      id: orderData.orderNumber || 'ORD' + Date.now().toString().slice(-8),
      customerName: `${orderData.customerInfo.firstName} ${orderData.customerInfo.lastName}`,
      phoneNumber: orderData.customerInfo.phone,
      email: orderData.customerInfo.email,
      status: 'pending', // M·ªõi t·∫°o s·∫Ω ·ªü tr·∫°ng th√°i ch·ªù x·ª≠ l√Ω
      createdAt: orderData.orderDate || new Date().toISOString(),
      totalAmount: orderData.finalTotal || orderData.orderTotal,
      subtotal: orderData.orderTotal,
      shippingFee: orderData.shippingFee || 0,
      discount: 0,
      shippingMethod: this.getShippingMethodText(orderData.customerInfo.city),
      shippingAddress: `${orderData.customerInfo.address}, ${orderData.customerInfo.district}, ${this.getCityText(orderData.customerInfo.city)}`,
      items: orderData.items.map(item => ({
        id: item.id,
        name: item.name,
        price: item.price,
        quantity: item.quantity,
        size: 'M·∫∑c ƒë·ªãnh', // C√≥ th·ªÉ c·∫≠p nh·∫≠t sau
        color: 'M·∫∑c ƒë·ªãnh', // C√≥ th·ªÉ c·∫≠p nh·∫≠t sau
        image: item.image || '/images/item-default.jpg'
      })),
      paymentInfo: orderData.paymentInfo
    }

    // L∆∞u v√†o localStorage ƒë·ªÉ persist
    this.saveOrderToLocalStorage(newOrder)
    
    return newOrder
  }

  // Save order to localStorage
  saveOrderToLocalStorage(order) {
    try {
      const existingOrders = JSON.parse(localStorage.getItem('userOrders') || '[]')
      existingOrders.unshift(order) // Th√™m v√†o ƒë·∫ßu danh s√°ch
      localStorage.setItem('userOrders', JSON.stringify(existingOrders))
      console.log('‚úÖ Order saved to localStorage:', order.id)
    } catch (error) {
      console.error('‚ùå Error saving order to localStorage:', error)
    }
  }

  // Get orders from localStorage
  getOrdersFromLocalStorage() {
    try {
      const orders = JSON.parse(localStorage.getItem('userOrders') || '[]')
      return orders
    } catch (error) {
      console.error('‚ùå Error getting orders from localStorage:', error)
      return []
    }
  }

  // Get shipping method text
  getShippingMethodText(city) {
    if (city === 'hanoi') {
      return 'Giao h√†ng ti√™u chu·∫©n (H√† N·ªôi)'
    } else if (city === 'hcm') {
      return 'Giao h√†ng ti√™u chu·∫©n (TP.HCM)'
    } else {
      return 'Giao h√†ng ti√™u chu·∫©n'
    }
  }

  // Get city text
  getCityText(city) {
    const cityMap = {
      'hanoi': 'H√† N·ªôi',
      'hcm': 'TP. H·ªì Ch√≠ Minh',
      'danang': 'ƒê√† N·∫µng',
      'haiphong': 'H·∫£i Ph√≤ng',
      'cantho': 'C·∫ßn Th∆°',
      'other': 'T·ªânh kh√°c'
    }
    return cityMap[city] || 'T·ªânh kh√°c'
  }

  // Format orders data from API response
  formatOrdersFromAPI(apiData) {
    try {
      // Ki·ªÉm tra n·∫øu API tr·∫£ v·ªÅ array
      if (Array.isArray(apiData)) {
        return apiData.map(order => this.formatSingleOrderFromAPI(order))
      }
      
      // Ki·ªÉm tra n·∫øu API tr·∫£ v·ªÅ object v·ªõi thu·ªôc t√≠nh data
      if (apiData && Array.isArray(apiData.data)) {
        return apiData.data.map(order => this.formatSingleOrderFromAPI(order))
      }
      
      // Ki·ªÉm tra n·∫øu API tr·∫£ v·ªÅ object v·ªõi thu·ªôc t√≠nh orders
      if (apiData && Array.isArray(apiData.orders)) {
        return apiData.orders.map(order => this.formatSingleOrderFromAPI(order))
      }
      
      // N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá, tr·∫£ v·ªÅ array r·ªóng
      console.warn('‚ö†Ô∏è API response format kh√¥ng h·ª£p l·ªá:', apiData)
      return []
    } catch (error) {
      console.error('‚ùå Error formatting orders from API:', error)
      return []
    }
  }
  
  // Format v√† l·ªçc ch·ªâ l·∫•y ƒë∆°n h√†ng ONLINE
  formatAndFilterOnlineOrders(apiData) {
    try {
      let orders = this.formatOrdersFromAPI(apiData)
      
      // L·ªåC: Ch·ªâ l·∫•y ƒë∆°n h√†ng ONLINE (loaiDon = 1)
      orders = orders.filter(order => {
        // Ki·ªÉm tra loaiDon t·ª´ API response
        const loaiDon = order.loaiDon || order.orderType || null
        const isOnline = loaiDon === 1 || loaiDon === '1' || loaiDon === 'ONLINE'
        
        if (!isOnline && loaiDon !== undefined) {
          console.log(`üö´ Lo·∫°i b·ªè ƒë∆°n h√†ng ${order.id} - loaiDon=${loaiDon} (kh√¥ng ph·∫£i online)`)
        }
        
        return isOnline || loaiDon === undefined // Cho ph√©p undefined ƒë·ªÉ t∆∞∆°ng th√≠ch v·ªõi d·ªØ li·ªáu c≈©
      })
      
      console.log(`‚úÖ Sau khi l·ªçc: ${orders.length} ƒë∆°n h√†ng ONLINE`)
      return orders
    } catch (error) {
      console.error('‚ùå Error filtering online orders:', error)
      return []
    }
  }
  
  // L·ªçc ƒë∆°n h√†ng online t·ª´ array c√≥ s·∫µn
  filterOnlineOrders(orders) {
    if (!Array.isArray(orders)) return []
    
    return orders.filter(order => {
      const loaiDon = order.loaiDon || order.orderType
      return loaiDon === 1 || loaiDon === '1' || loaiDon === 'ONLINE' || loaiDon === undefined
    })
  }

  // Format single order from API
  formatSingleOrderFromAPI(apiOrder) {
    try {
      const items = this.formatOrderItems(apiOrder.chiTietDonHang || apiOrder.items || apiOrder.sanPham || [])
      // S·ªë l∆∞·ª£ng s·∫£n ph·∫©m v√† t·ªïng s·ªë l∆∞·ª£ng t·ª´ nhi·ªÅu tr∆∞·ªùng kh√°c nhau
      const apiItemCount = apiOrder.soLuongSanPham || apiOrder.tongSanPham || apiOrder.soSanPham || apiOrder.itemCount
      const apiTotalQty = apiOrder.tongSoLuong || apiOrder.tongSoLuongSanPham || apiOrder.totalQuantity || apiOrder.soLuong
      const computedTotalQty = items.reduce((sum, it) => sum + (it.quantity || 0), 0)
      const finalItemCount = apiItemCount != null ? parseInt(apiItemCount) : (items.length || 0)
      const finalTotalQty = apiTotalQty != null ? parseInt(apiTotalQty) : computedTotalQty

      return {
        id: apiOrder.maDon || apiOrder.maDonHang || apiOrder.orderNumber || apiOrder.id || 'ORD' + Date.now(),
        databaseId: apiOrder.id, // L∆∞u database ID ri√™ng ƒë·ªÉ tham chi·∫øu
        customerName: apiOrder.tenKhachHang || apiOrder.customerName || apiOrder.hoTen || 'Kh√°ch h√†ng',
        phoneNumber: apiOrder.soDienThoai || apiOrder.phoneNumber || apiOrder.sdt || '',
        email: apiOrder.email || apiOrder.emailKhachHang || '',
        status: this.mapOrderStatus(apiOrder.trangThai || apiOrder.status || 'pending'),
        createdAt: apiOrder.ngayTao || apiOrder.createdAt || apiOrder.ngayDat || new Date().toISOString(),
        totalAmount: apiOrder.tongTien || apiOrder.totalAmount || apiOrder.giaTri || 0,
        subtotal: apiOrder.tamTinh || apiOrder.subtotal || apiOrder.tongTien || 0,
        shippingFee: apiOrder.phiVanChuyen || apiOrder.shippingFee || apiOrder.phiGiaoHang || 0,
        discount: apiOrder.giamGia || apiOrder.discount || apiOrder.khuyenMai || 0,
        shippingMethod: apiOrder.phuongThucGiaoHang || apiOrder.shippingMethod || 'Giao h√†ng ti√™u chu·∫©n',
        shippingAddress: apiOrder.diaChiGiaoHang || apiOrder.shippingAddress || apiOrder.diaChi || '',
        items: items,
        itemCount: finalItemCount,
        totalQuantity: finalTotalQty,
        paymentInfo: this.formatPaymentInfo(apiOrder.thongTinThanhToan || apiOrder.paymentInfo || {}),
        loaiDon: apiOrder.loaiDon, // Gi·ªØ l·∫°i loaiDon ƒë·ªÉ ki·ªÉm tra
        orderType: apiOrder.loaiDon === 1 ? 'ONLINE' : (apiOrder.loaiDon === 0 ? 'OFFLINE' : 'UNKNOWN')
      }
    } catch (error) {
      console.error('‚ùå Error formatting single order:', error, apiOrder)
      return {
        id: 'ORD' + Date.now(),
        customerName: 'Kh√°ch h√†ng',
        phoneNumber: '',
        email: '',
        status: 'pending',
        createdAt: new Date().toISOString(),
        totalAmount: 0,
        subtotal: 0,
        shippingFee: 0,
        discount: 0,
        shippingMethod: 'Giao h√†ng ti√™u chu·∫©n',
        shippingAddress: '',
        items: [],
        paymentInfo: {}
      }
    }
  }

  // Map order status from API to frontend format
  mapOrderStatus(apiStatus) {
    const statusMap = {
      // String enums (if any)
      'CHO_XU_LY': 'pending',
      'DA_XAC_NHAN': 'confirmed',
      'CHO_GIAO': 'ready_to_ship',
      'DANG_GIAO': 'shipping',
      'DA_GIAO': 'completed',
      'DA_HUY': 'cancelled',
      'pending': 'pending',
      'confirmed': 'confirmed',
      'ready_to_ship': 'ready_to_ship',
      'shipping': 'shipping',
      'delivered': 'completed',
      'cancelled': 'cancelled',
      // Integer statuses from backend:
      // 1=Ch·ªù x√°c nh·∫≠n, 2=ƒê√£ x√°c nh·∫≠n, 3=Ch·ªù giao, 4=ƒêang giao, 5=Ho√†n th√†nh, 6=ƒê√£ h·ªßy
      1: 'pending',
      2: 'confirmed',
      3: 'ready_to_ship',
      4: 'shipping',
      5: 'completed',
      6: 'cancelled'
    }
    return statusMap[apiStatus] || 'pending'
  }

  // Format order items from API
  formatOrderItems(apiItems) {
    if (!Array.isArray(apiItems)) return []
    
    return apiItems.map(item => ({
      id: item.id || item.maSanPham || item.productId || Date.now(),
      name: item.tenSanPham || item.name || item.ten || 'S·∫£n ph·∫©m',
      price: item.gia || item.price || item.giaTien || 0,
      quantity: item.soLuong || item.quantity || item.sl || 1,
      size: item.kichCo || item.size || 'M·∫∑c ƒë·ªãnh',
      color: item.mauSac || item.color || 'M·∫∑c ƒë·ªãnh',
      image: item.hinhAnh || item.image || item.anh || '/images/item-default.jpg'
    }))
  }

  // Format payment info from API
  formatPaymentInfo(apiPaymentInfo) {
    if (!apiPaymentInfo || typeof apiPaymentInfo !== 'object') return {}
    
    return {
      id: apiPaymentInfo.id || apiPaymentInfo.maThanhToan || '',
      maGiaoDich: apiPaymentInfo.maGiaoDich || apiPaymentInfo.transactionId || '',
      trangThai: apiPaymentInfo.trangThai || apiPaymentInfo.status || 0,
      phuongThucId: apiPaymentInfo.phuongThucId || apiPaymentInfo.paymentMethodId || 1
    }
  }

  // Mock data for development/testing - Empty array ƒë·ªÉ b·∫Øt ƒë·∫ßu v·ªõi danh s√°ch tr·ªëng
  getMockOrders() {
    // Tr·∫£ v·ªÅ d·ªØ li·ªáu t·ª´ localStorage thay v√¨ mock data c·ªë ƒë·ªãnh
    return this.getOrdersFromLocalStorage()
  }

  getMockOrderById(orderId) {
    const orders = this.getMockOrders()
    return orders.find(order => order.id === orderId) || null
  }
}

export default new OrderService()