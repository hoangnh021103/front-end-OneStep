// Order Service - API calls for order management
const API_BASE_URL = 'http://localhost:8080/api'

class OrderService {
  // Get authorization headers
  getAuthHeaders() {
    const token = localStorage.getItem('authToken')
    return {
      'Content-Type': 'application/json',
      'Authorization': token ? `Bearer ${token}` : ''
    }
  }

  // Get all orders for current user
  async getUserOrders(userId) {
    try {
      // Th·ª≠ g·ªçi API m·ªõi tr∆∞·ªõc
      const response = await fetch(`${API_BASE_URL}/don-hang/hien-thi`, {
        method: 'GET',
        headers: this.getAuthHeaders()
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const data = await response.json()
      console.log('‚úÖ API /don-hang/hien-thi response:', data)
      
      // Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu t·ª´ API sang format c·ªßa frontend
      const formattedOrders = this.formatOrdersFromAPI(data)
      return formattedOrders || []
    } catch (error) {
      console.error('Error fetching orders from API:', error)
      // Fallback to localStorage data
      return this.getMockOrders()
    }
  }

  // Get order by ID
  async getOrderById(orderId) {
    try {
      const response = await fetch(`${API_BASE_URL}/orders/${orderId}`, {
        method: 'GET',
        headers: this.getAuthHeaders()
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const data = await response.json()
      return data
    } catch (error) {
      console.error('Error fetching order by ID:', error)
      // Return mock data for development
      return this.getMockOrderById(orderId)
    }
  }

  // Create new order
  async createOrder(orderData) {
    try {
      // Chu·∫©n b·ªã d·ªØ li·ªáu ƒë∆°n h√†ng theo format c·ªßa backend
      const backendOrderData = this.formatOrderForBackend(orderData)
      
      console.log('üîÑ G·ª≠i ƒë∆°n h√†ng l√™n backend:', backendOrderData)
      
      const response = await fetch(`${API_BASE_URL}/don-hang/add`, {
        method: 'POST',
        headers: this.getAuthHeaders(),
        body: JSON.stringify(backendOrderData)
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const data = await response.json()
      console.log('‚úÖ ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng tr√™n backend:', data)
      return data
    } catch (error) {
      console.error('Error creating order:', error)
      throw error
    }
  }

  // Cancel order
  async cancelOrder(orderId) {
    try {
      const response = await fetch(`${API_BASE_URL}/orders/${orderId}/cancel`, {
        method: 'PUT',
        headers: this.getAuthHeaders()
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const data = await response.json()
      return data
    } catch (error) {
      console.error('Error cancelling order:', error)
      // Fallback: Update local storage
      this.updateOrderStatusInLocalStorage(orderId, 'cancelled')
      return { success: true, message: 'Order cancelled locally' }
    }
  }

  // Update order status in localStorage
  updateOrderStatusInLocalStorage(orderId, newStatus) {
    try {
      const orders = this.getOrdersFromLocalStorage()
      const orderIndex = orders.findIndex(order => order.id === orderId)
      
      if (orderIndex !== -1) {
        orders[orderIndex].status = newStatus
        orders[orderIndex].updatedAt = new Date().toISOString()
        localStorage.setItem('userOrders', JSON.stringify(orders))
        console.log(`‚úÖ Order ${orderId} status updated to ${newStatus} in localStorage`)
      }
    } catch (error) {
      console.error('‚ùå Error updating order status in localStorage:', error)
    }
  }


  // Update order status
  async updateOrderStatus(orderId, status) {
    try {
      const response = await fetch(`${API_BASE_URL}/orders/${orderId}/status`, {
        method: 'PUT',
        headers: this.getAuthHeaders(),
        body: JSON.stringify({ status })
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const data = await response.json()
      return data
    } catch (error) {
      console.error('Error updating order status:', error)
      throw error
    }
  }

  // Search orders by criteria
  async searchOrders(criteria) {
    try {
      const queryParams = new URLSearchParams(criteria)
      const response = await fetch(`${API_BASE_URL}/orders/search?${queryParams}`, {
        method: 'GET',
        headers: this.getAuthHeaders()
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const data = await response.json()
      return data || []
    } catch (error) {
      console.error('Error searching orders:', error)
      return []
    }
  }

  // Create new order from checkout data
  async createOrderFromCheckout(orderData) {
    try {
      console.log('üîÑ T·∫°o ƒë∆°n h√†ng t·ª´ checkout:', orderData)
      
      // G·ª≠i ƒë∆°n h√†ng l√™n backend tr∆∞·ªõc
      const backendResponse = await this.createOrder(orderData)
      console.log('‚úÖ Backend response:', backendResponse)
      
      // T·∫°o ƒë∆°n h√†ng cho frontend
      const newOrder = {
        id: orderData.orderNumber || 'ORD' + Date.now().toString().slice(-8),
        customerName: `${orderData.customerInfo.firstName} ${orderData.customerInfo.lastName}`,
        phoneNumber: orderData.customerInfo.phone,
        email: orderData.customerInfo.email,
        status: 'pending', // M·ªõi t·∫°o s·∫Ω ·ªü tr·∫°ng th√°i ch·ªù x·ª≠ l√Ω
        createdAt: orderData.orderDate || new Date().toISOString(),
        totalAmount: orderData.finalTotal || orderData.orderTotal,
        subtotal: orderData.orderTotal,
        shippingFee: orderData.shippingFee || 0,
        discount: 0,
        shippingMethod: this.getShippingMethodText(orderData.customerInfo.city),
        shippingAddress: `${orderData.customerInfo.address}, ${orderData.customerInfo.district}, ${this.getCityText(orderData.customerInfo.city)}`,
        items: orderData.items.map(item => ({
          id: item.id,
          name: item.name,
          price: item.price,
          quantity: item.quantity,
          size: 'M·∫∑c ƒë·ªãnh', // C√≥ th·ªÉ c·∫≠p nh·∫≠t sau
          color: 'M·∫∑c ƒë·ªãnh', // C√≥ th·ªÉ c·∫≠p nh·∫≠t sau
          image: item.image || '/images/item-default.jpg'
        })),
        paymentInfo: orderData.paymentInfo,
        backendId: backendResponse?.id || backendResponse?.maDon || null // L∆∞u ID t·ª´ backend
      }

      // L∆∞u v√†o localStorage ƒë·ªÉ persist
      this.saveOrderToLocalStorage(newOrder)
      
      console.log('‚úÖ ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng:', newOrder)
      return newOrder
    } catch (error) {
      console.error('‚ùå L·ªói khi t·∫°o ƒë∆°n h√†ng t·ª´ checkout:', error)
      
      // Fallback: T·∫°o ƒë∆°n h√†ng local n·∫øu backend fail
      console.log('üîÑ Fallback: T·∫°o ƒë∆°n h√†ng local...')
      const fallbackOrder = {
        id: orderData.orderNumber || 'ORD' + Date.now().toString().slice(-8),
        customerName: `${orderData.customerInfo.firstName} ${orderData.customerInfo.lastName}`,
        phoneNumber: orderData.customerInfo.phone,
        email: orderData.customerInfo.email,
        status: 'pending',
        createdAt: orderData.orderDate || new Date().toISOString(),
        totalAmount: orderData.finalTotal || orderData.orderTotal,
        subtotal: orderData.orderTotal,
        shippingFee: orderData.shippingFee || 0,
        discount: 0,
        shippingMethod: this.getShippingMethodText(orderData.customerInfo.city),
        shippingAddress: `${orderData.customerInfo.address}, ${orderData.customerInfo.district}, ${this.getCityText(orderData.customerInfo.city)}`,
        items: orderData.items.map(item => ({
          id: item.id,
          name: item.name,
          price: item.price,
          quantity: item.quantity,
          size: 'M·∫∑c ƒë·ªãnh',
          color: 'M·∫∑c ƒë·ªãnh',
          image: item.image || '/images/item-default.jpg'
        })),
        paymentInfo: orderData.paymentInfo,
        backendId: null,
        isLocalOnly: true // ƒê√°nh d·∫•u l√† ƒë∆°n h√†ng ch·ªâ c√≥ local
      }
      
      this.saveOrderToLocalStorage(fallbackOrder)
      return fallbackOrder
    }
  }

  // Save order to localStorage
  saveOrderToLocalStorage(order) {
    try {
      const existingOrders = JSON.parse(localStorage.getItem('userOrders') || '[]')
      existingOrders.unshift(order) // Th√™m v√†o ƒë·∫ßu danh s√°ch
      localStorage.setItem('userOrders', JSON.stringify(existingOrders))
      console.log('‚úÖ Order saved to localStorage:', order.id)
    } catch (error) {
      console.error('‚ùå Error saving order to localStorage:', error)
    }
  }

  // Get orders from localStorage
  getOrdersFromLocalStorage() {
    try {
      const orders = JSON.parse(localStorage.getItem('userOrders') || '[]')
      return orders
    } catch (error) {
      console.error('‚ùå Error getting orders from localStorage:', error)
      return []
    }
  }

  // Get shipping method text
  getShippingMethodText(city) {
    if (city === 'hanoi') {
      return 'Giao h√†ng ti√™u chu·∫©n (H√† N·ªôi)'
    } else if (city === 'hcm') {
      return 'Giao h√†ng ti√™u chu·∫©n (TP.HCM)'
    } else {
      return 'Giao h√†ng ti√™u chu·∫©n'
    }
  }

  // Get city text
  getCityText(city) {
    const cityMap = {
      'hanoi': 'H√† N·ªôi',
      'hcm': 'TP. H·ªì Ch√≠ Minh',
      'danang': 'ƒê√† N·∫µng',
      'haiphong': 'H·∫£i Ph√≤ng',
      'cantho': 'C·∫ßn Th∆°',
      'other': 'T·ªânh kh√°c'
    }
    return cityMap[city] || 'T·ªânh kh√°c'
  }

  // Format orders data from API response
  formatOrdersFromAPI(apiData) {
    try {
      // Ki·ªÉm tra n·∫øu API tr·∫£ v·ªÅ array
      if (Array.isArray(apiData)) {
        return apiData.map(order => this.formatSingleOrderFromAPI(order))
      }
      
      // Ki·ªÉm tra n·∫øu API tr·∫£ v·ªÅ object v·ªõi thu·ªôc t√≠nh data
      if (apiData && Array.isArray(apiData.data)) {
        return apiData.data.map(order => this.formatSingleOrderFromAPI(order))
      }
      
      // Ki·ªÉm tra n·∫øu API tr·∫£ v·ªÅ object v·ªõi thu·ªôc t√≠nh orders
      if (apiData && Array.isArray(apiData.orders)) {
        return apiData.orders.map(order => this.formatSingleOrderFromAPI(order))
      }
      
      // N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá, tr·∫£ v·ªÅ array r·ªóng
      console.warn('‚ö†Ô∏è API response format kh√¥ng h·ª£p l·ªá:', apiData)
      return []
    } catch (error) {
      console.error('‚ùå Error formatting orders from API:', error)
      return []
    }
  }

  // Format single order from API
  formatSingleOrderFromAPI(apiOrder) {
    try {
      return {
        id: apiOrder.id || apiOrder.maDonHang || apiOrder.orderId || 'ORD' + Date.now(),
        customerName: apiOrder.tenKhachHang || apiOrder.customerName || apiOrder.hoTen || 'Kh√°ch h√†ng',
        phoneNumber: apiOrder.soDienThoai || apiOrder.phoneNumber || apiOrder.sdt || '',
        email: apiOrder.email || apiOrder.emailKhachHang || '',
        status: this.mapOrderStatus(apiOrder.trangThai || apiOrder.status || 'pending'),
        createdAt: apiOrder.ngayTao || apiOrder.createdAt || apiOrder.ngayDat || new Date().toISOString(),
        totalAmount: apiOrder.tongTien || apiOrder.totalAmount || apiOrder.giaTri || 0,
        subtotal: apiOrder.tamTinh || apiOrder.subtotal || apiOrder.tongTien || 0,
        shippingFee: apiOrder.phiVanChuyen || apiOrder.shippingFee || apiOrder.phiGiaoHang || 0,
        discount: apiOrder.giamGia || apiOrder.discount || apiOrder.khuyenMai || 0,
        shippingMethod: apiOrder.phuongThucGiaoHang || apiOrder.shippingMethod || 'Giao h√†ng ti√™u chu·∫©n',
        shippingAddress: apiOrder.diaChiGiaoHang || apiOrder.shippingAddress || apiOrder.diaChi || '',
        items: this.formatOrderItems(apiOrder.chiTietDonHang || apiOrder.items || apiOrder.sanPham || []),
        paymentInfo: this.formatPaymentInfo(apiOrder.thongTinThanhToan || apiOrder.paymentInfo || {})
      }
    } catch (error) {
      console.error('‚ùå Error formatting single order:', error, apiOrder)
      return {
        id: 'ORD' + Date.now(),
        customerName: 'Kh√°ch h√†ng',
        phoneNumber: '',
        email: '',
        status: 'pending',
        createdAt: new Date().toISOString(),
        totalAmount: 0,
        subtotal: 0,
        shippingFee: 0,
        discount: 0,
        shippingMethod: 'Giao h√†ng ti√™u chu·∫©n',
        shippingAddress: '',
        items: [],
        paymentInfo: {}
      }
    }
  }

  // Map order status from API to frontend format
  mapOrderStatus(apiStatus) {
    const statusMap = {
      'CHO_XU_LY': 'pending',
      'CHO_XAC_NHAN': 'pending',
      'DA_XAC_NHAN': 'confirmed',
      'CHO_GIAO': 'shipping',
      'DANG_GIAO': 'delivering',
      'DA_GIAO': 'delivered',
      'HOAN_THANH': 'done',
      'DA_HOAN_THANH': 'done',
      'DA_HUY': 'cancelled',
      'pending': 'pending',
      'confirmed': 'confirmed',
      'shipping': 'shipping',
      'delivering': 'delivering',
      'done': 'done',
      'delivered': 'delivered',
      'cancelled': 'cancelled',
      0: 'pending',
      1: 'confirmed',
      2: 'shipping',
      3: 'delivering',
      4: 'done',
      5: 'delivered',
      6: 'cancelled'
    }
    return statusMap[apiStatus] || 'pending'
  }

  // Format order items from API
  formatOrderItems(apiItems) {
    if (!Array.isArray(apiItems)) return []
    
    return apiItems.map(item => ({
      id: item.id || item.maSanPham || item.productId || Date.now(),
      name: item.tenSanPham || item.name || item.ten || 'S·∫£n ph·∫©m',
      price: item.gia || item.price || item.giaTien || 0,
      quantity: item.soLuong || item.quantity || item.sl || 1,
      size: item.kichCo || item.size || 'M·∫∑c ƒë·ªãnh',
      color: item.mauSac || item.color || 'M·∫∑c ƒë·ªãnh',
      image: item.hinhAnh || item.image || item.anh || '/images/item-default.jpg'
    }))
  }

  // Format payment info from API
  formatPaymentInfo(apiPaymentInfo) {
    if (!apiPaymentInfo || typeof apiPaymentInfo !== 'object') return {}
    
    return {
      id: apiPaymentInfo.id || apiPaymentInfo.maThanhToan || '',
      maGiaoDich: apiPaymentInfo.maGiaoDich || apiPaymentInfo.transactionId || '',
      trangThai: apiPaymentInfo.trangThai || apiPaymentInfo.status || 0,
      phuongThucId: apiPaymentInfo.phuongThucId || apiPaymentInfo.paymentMethodId || 1
    }
  }

  // Format order data for backend API
  formatOrderForBackend(orderData) {
    try {
      const customerInfo = orderData.customerInfo || {}
      const currentDate = new Date().toISOString().split('T')[0]
      
      return {
        // Th√¥ng tin kh√°ch h√†ng
        khachHangId: 0, // S·∫Ω ƒë∆∞·ª£c t·∫°o m·ªõi n·∫øu ch∆∞a c√≥
        hoTen: `${customerInfo.firstName || ''} ${customerInfo.lastName || ''}`.trim() || 'Kh√°ch h√†ng',
        soDienThoai: customerInfo.phone || '',
        email: customerInfo.email || '',
        
        // Th√¥ng tin ƒë∆°n h√†ng
        maDon: orderData.orderNumber || 'ORD' + Date.now().toString().slice(-8),
        loaiDon: 1, // 1 = ONLINE (t·ª´ trang ch·ªß)
        tongTien: parseFloat(orderData.finalTotal || orderData.orderTotal || 0),
        tongTienGoc: parseFloat(orderData.orderTotal || 0),
        tienGiam: parseFloat(orderData.discount || 0),
        tienShip: parseFloat(orderData.shippingFee || 0),
        
        // ƒê·ªãa ch·ªâ giao h√†ng
        diaChiGiaoHang: customerInfo.address ? 
          `${customerInfo.address}, ${customerInfo.district}, ${this.getCityText(customerInfo.city)}` : '',
        
        // Th√¥ng tin thanh to√°n
        phuongThucThanhToan: orderData.paymentMethod || 'Thanh to√°n khi nh·∫≠n h√†ng (COD)',
        
        // Tr·∫°ng th√°i v√† ng√†y th√°ng
        trangThai: 1, // 1 = Ch·ªù x√°c nh·∫≠n
        ngayXacNhan: currentDate,
        ngayCapNhat: currentDate,
        ngayDuKien: this.calculateExpectedDeliveryDate(customerInfo.city),
        
        // Th√¥ng tin kh√°c
        ghiChu: customerInfo.note || `ƒê∆°n h√†ng t·ª´ trang ch·ªß - ${new Date().toLocaleString('vi-VN')}`,
        nguoiTao: 'Kh√°ch h√†ng',
        nguoiCapNhat: 'Kh√°ch h√†ng',
        daXoa: 0,
        
        // Chi ti·∫øt ƒë∆°n h√†ng
        chiTietDonHang: this.formatOrderItemsForBackend(orderData.items || []),
        
        // Th√¥ng tin voucher n·∫øu c√≥
        voucherId: orderData.voucherId || 0,
        maGiamGia: orderData.discountCode || null
      }
    } catch (error) {
      console.error('‚ùå Error formatting order for backend:', error)
      throw error
    }
  }

  // Format order items for backend
  formatOrderItemsForBackend(items) {
    if (!Array.isArray(items)) return []
    
    return items.map((item, index) => ({
      id: item.id || Date.now() + index,
      tenSanPham: item.name || 'S·∫£n ph·∫©m',
      gia: parseFloat(item.price || 0),
      soLuong: parseInt(item.quantity || 1),
      kichCo: item.size || 'M·∫∑c ƒë·ªãnh',
      mauSac: item.color || 'M·∫∑c ƒë·ªãnh',
      hinhAnh: item.image || '/images/item-default.jpg',
      brand: item.brand || 'OneStep'
    }))
  }

  // Calculate expected delivery date based on city
  calculateExpectedDeliveryDate(city) {
    const currentDate = new Date()
    let deliveryDays = 3 // M·∫∑c ƒë·ªãnh 3 ng√†y
    
    // ƒêi·ªÅu ch·ªânh s·ªë ng√†y giao h√†ng d·ª±a tr√™n th√†nh ph·ªë
    if (city === 'hanoi' || city === 'hcm') {
      deliveryDays = 1 // N·ªôi th√†nh H√† N·ªôi/HCM: 1 ng√†y
    } else if (city === 'danang' || city === 'haiphong' || city === 'cantho') {
      deliveryDays = 2 // Th√†nh ph·ªë l·ªõn: 2 ng√†y
    }
    
    const expectedDate = new Date(currentDate.getTime() + (deliveryDays * 24 * 60 * 60 * 1000))
    return expectedDate.toISOString().split('T')[0]
  }

  // Mock data for development/testing - Empty array ƒë·ªÉ b·∫Øt ƒë·∫ßu v·ªõi danh s√°ch tr·ªëng
  getMockOrders() {
    // Tr·∫£ v·ªÅ d·ªØ li·ªáu t·ª´ localStorage thay v√¨ mock data c·ªë ƒë·ªãnh
    return this.getOrdersFromLocalStorage()
  }

  getMockOrderById(orderId) {
    const orders = this.getMockOrders()
    return orders.find(order => order.id === orderId) || null
  }
}

export default new OrderService()